diff --git a/node_modules/@metaplex/js/lib/index.browser.esm.js b/node_modules/@metaplex/js/lib/index.browser.esm.js
index b9b004d..d1fd6f7 100644
--- a/node_modules/@metaplex/js/lib/index.browser.esm.js
+++ b/node_modules/@metaplex/js/lib/index.browser.esm.js
@@ -501,21 +501,31 @@ const initStoreV2 = ({ connection, wallet, settingsUri = null, isPublic = true,
     return { storeId, configId, txId };
 });
 
-const mintNFT = ({ connection, wallet, uri, maxSupply, }) => __awaiter(void 0, void 0, void 0, function* () {
+const mintNFT = ({ connection, wallet, uri, maxSupply, keypair, passToken, passMint, owner}) => __awaiter(void 0, void 0, void 0, function* () {
+    // burn transaction
+    const tx = new Transaction({ feePayer: wallet.publicKey }).add(Token.createBurnInstruction(TOKEN_PROGRAM_ID, passMint, passToken, owner !== null && owner !== void 0 ? owner : wallet.publicKey, [], 1));
+    tx.add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, passToken, wallet.publicKey, owner !== null && owner !== void 0 ? owner : wallet.publicKey, []));
+    // mint transactions
     const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);
     const metadataPDA = yield Metadata.getPDA(mint.publicKey);
     const editionPDA = yield MasterEdition.getPDA(mint.publicKey);
     const { name, symbol, seller_fee_basis_points, properties: { creators }, } = yield lookup(uri);
     const creatorsData = creators.reduce((memo, { address, share }) => {
-        const verified = address === wallet.publicKey.toString();
-        const creator = new Creator({
+        //const verified = address === wallet.publicKey.toString();
+        const creator = new mplTokenMetadata.Creator({
             address,
             share,
-            verified,
+            verified: 0, // avoid error 0x36: You cannot unilaterally verify another creator, they must sign
         });
         memo = [...memo, creator];
         return memo;
     }, []); 
+    creatorsData.push(new Creator({
+        address: keypair.publicKey.toBase58(),
+        share: 0,
+        verified: 1,
+    })) // add our wallet that can sign
+    
     const metadataData = new MetadataDataData({
         name,
         symbol,
@@ -528,22 +538,23 @@ const mintNFT = ({ connection, wallet, uri, maxSupply, }) => __awaiter(void 0, v
     }, {
         metadata: metadataPDA,
         metadataData,
-        updateAuthority: wallet.publicKey,
+        updateAuthority: keypair.publicKey, // use our wallet that can sign
         mint: mint.publicKey,
         mintAuthority: wallet.publicKey,
     });
     const masterEditionTx = new CreateMasterEdition({ feePayer: wallet.publicKey }, {
         edition: editionPDA,
         metadata: metadataPDA,
-        updateAuthority: wallet.publicKey,
+        updateAuthority: keypair.publicKey, // use our wallet that can sign
         mint: mint.publicKey,
         mintAuthority: wallet.publicKey,
         maxSupply: maxSupply || maxSupply === 0 ? new BN(maxSupply) : null,
     });
     const txId = yield sendTransaction({
         connection,
-        signers: [mint],
+        signers: [mint,keypair],
         txs: [
+            tx,
             createMintTx,
             createMetadataTx,
             createAssociatedTokenAccountTx,
